"""LCM type definitions
This file automatically generated by lcm.
DO NOT MODIFY BY HAND!!!!
"""

try:
    import cStringIO.StringIO as BytesIO
except ImportError:
    from io import BytesIO
import struct

class debug_data_lcmt(object):
    __slots__ = ["swing_spheres_enabled", "swing_sphere_pos", "swing_num_spheres", "traj_spheres_enabled", "traj_num_spheres", "gaitNumber", "horizonLength", "iterationCounter", "gaitIterations", "swingTimeRemaining", "swingTimes", "stance_time", "Pf", "contactStates", "swingStates", "pFoot", "PlaneSlope", "pBody_des", "pBody_est", "pDesLeg", "vDesLeg", "PlaneHeight", "sim_applied_force", "estimated_body_forces", "sim_joint_acc", "estimated_joint_acc", "footSwingTrajectoriesPosition"]

    __typenames__ = ["int8_t", "float", "int64_t", "int8_t", "int64_t", "int64_t", "int64_t", "int64_t", "int64_t", "float", "float", "float", "float", "float", "float", "float", "float", "float", "float", "float", "float", "float", "float", "float", "float", "float", "float"]

    __dimensions__ = [None, [2], None, None, None, None, None, None, None, [4], [4], None, [3], [4], [4], [12], None, [3], [3], [3], [3], [3], [3], [3], [12], [12], [12]]

    def __init__(self):
        self.swing_spheres_enabled = 0
        self.swing_sphere_pos = [ 0.0 for dim0 in range(2) ]
        self.swing_num_spheres = 0
        self.traj_spheres_enabled = 0
        self.traj_num_spheres = 0
        self.gaitNumber = 0
        self.horizonLength = 0
        self.iterationCounter = 0
        self.gaitIterations = 0
        self.swingTimeRemaining = [ 0.0 for dim0 in range(4) ]
        self.swingTimes = [ 0.0 for dim0 in range(4) ]
        self.stance_time = 0.0
        self.Pf = [ 0.0 for dim0 in range(3) ]
        self.contactStates = [ 0.0 for dim0 in range(4) ]
        self.swingStates = [ 0.0 for dim0 in range(4) ]
        self.pFoot = [ 0.0 for dim0 in range(12) ]
        self.PlaneSlope = 0.0
        self.pBody_des = [ 0.0 for dim0 in range(3) ]
        self.pBody_est = [ 0.0 for dim0 in range(3) ]
        self.pDesLeg = [ 0.0 for dim0 in range(3) ]
        self.vDesLeg = [ 0.0 for dim0 in range(3) ]
        self.PlaneHeight = [ 0.0 for dim0 in range(3) ]
        self.sim_applied_force = [ 0.0 for dim0 in range(3) ]
        self.estimated_body_forces = [ 0.0 for dim0 in range(3) ]
        self.sim_joint_acc = [ 0.0 for dim0 in range(12) ]
        self.estimated_joint_acc = [ 0.0 for dim0 in range(12) ]
        self.footSwingTrajectoriesPosition = [ 0.0 for dim0 in range(12) ]

    def encode(self):
        buf = BytesIO()
        buf.write(debug_data_lcmt._get_packed_fingerprint())
        self._encode_one(buf)
        return buf.getvalue()

    def _encode_one(self, buf):
        buf.write(struct.pack(">b", self.swing_spheres_enabled))
        buf.write(struct.pack('>2f', *self.swing_sphere_pos[:2]))
        buf.write(struct.pack(">qbqqqqq", self.swing_num_spheres, self.traj_spheres_enabled, self.traj_num_spheres, self.gaitNumber, self.horizonLength, self.iterationCounter, self.gaitIterations))
        buf.write(struct.pack('>4f', *self.swingTimeRemaining[:4]))
        buf.write(struct.pack('>4f', *self.swingTimes[:4]))
        buf.write(struct.pack(">f", self.stance_time))
        buf.write(struct.pack('>3f', *self.Pf[:3]))
        buf.write(struct.pack('>4f', *self.contactStates[:4]))
        buf.write(struct.pack('>4f', *self.swingStates[:4]))
        buf.write(struct.pack('>12f', *self.pFoot[:12]))
        buf.write(struct.pack(">f", self.PlaneSlope))
        buf.write(struct.pack('>3f', *self.pBody_des[:3]))
        buf.write(struct.pack('>3f', *self.pBody_est[:3]))
        buf.write(struct.pack('>3f', *self.pDesLeg[:3]))
        buf.write(struct.pack('>3f', *self.vDesLeg[:3]))
        buf.write(struct.pack('>3f', *self.PlaneHeight[:3]))
        buf.write(struct.pack('>3f', *self.sim_applied_force[:3]))
        buf.write(struct.pack('>3f', *self.estimated_body_forces[:3]))
        buf.write(struct.pack('>12f', *self.sim_joint_acc[:12]))
        buf.write(struct.pack('>12f', *self.estimated_joint_acc[:12]))
        buf.write(struct.pack('>12f', *self.footSwingTrajectoriesPosition[:12]))

    def decode(data):
        if hasattr(data, 'read'):
            buf = data
        else:
            buf = BytesIO(data)
        if buf.read(8) != debug_data_lcmt._get_packed_fingerprint():
            raise ValueError("Decode error")
        return debug_data_lcmt._decode_one(buf)
    decode = staticmethod(decode)

    def _decode_one(buf):
        self = debug_data_lcmt()
        self.swing_spheres_enabled = struct.unpack(">b", buf.read(1))[0]
        self.swing_sphere_pos = struct.unpack('>2f', buf.read(8))
        self.swing_num_spheres, self.traj_spheres_enabled, self.traj_num_spheres, self.gaitNumber, self.horizonLength, self.iterationCounter, self.gaitIterations = struct.unpack(">qbqqqqq", buf.read(49))
        self.swingTimeRemaining = struct.unpack('>4f', buf.read(16))
        self.swingTimes = struct.unpack('>4f', buf.read(16))
        self.stance_time = struct.unpack(">f", buf.read(4))[0]
        self.Pf = struct.unpack('>3f', buf.read(12))
        self.contactStates = struct.unpack('>4f', buf.read(16))
        self.swingStates = struct.unpack('>4f', buf.read(16))
        self.pFoot = struct.unpack('>12f', buf.read(48))
        self.PlaneSlope = struct.unpack(">f", buf.read(4))[0]
        self.pBody_des = struct.unpack('>3f', buf.read(12))
        self.pBody_est = struct.unpack('>3f', buf.read(12))
        self.pDesLeg = struct.unpack('>3f', buf.read(12))
        self.vDesLeg = struct.unpack('>3f', buf.read(12))
        self.PlaneHeight = struct.unpack('>3f', buf.read(12))
        self.sim_applied_force = struct.unpack('>3f', buf.read(12))
        self.estimated_body_forces = struct.unpack('>3f', buf.read(12))
        self.sim_joint_acc = struct.unpack('>12f', buf.read(48))
        self.estimated_joint_acc = struct.unpack('>12f', buf.read(48))
        self.footSwingTrajectoriesPosition = struct.unpack('>12f', buf.read(48))
        return self
    _decode_one = staticmethod(_decode_one)

    def _get_hash_recursive(parents):
        if debug_data_lcmt in parents: return 0
        tmphash = (0x464bcb173e701c29) & 0xffffffffffffffff
        tmphash  = (((tmphash<<1)&0xffffffffffffffff) + (tmphash>>63)) & 0xffffffffffffffff
        return tmphash
    _get_hash_recursive = staticmethod(_get_hash_recursive)
    _packed_fingerprint = None

    def _get_packed_fingerprint():
        if debug_data_lcmt._packed_fingerprint is None:
            debug_data_lcmt._packed_fingerprint = struct.pack(">Q", debug_data_lcmt._get_hash_recursive([]))
        return debug_data_lcmt._packed_fingerprint
    _get_packed_fingerprint = staticmethod(_get_packed_fingerprint)

    def get_hash(self):
        """Get the LCM hash of the struct"""
        return struct.unpack(">Q", debug_data_lcmt._get_packed_fingerprint())[0]

